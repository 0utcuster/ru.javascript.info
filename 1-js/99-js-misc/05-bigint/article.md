# BigInt

[recent caniuse="bigint"]

`BigInt` это специальный числовой тип, который предоставляет возможность рабоать с целыми числами произвольной длины.

Чтобы создать значение типа `BigInt` необходимо добавить `n` в конец числового литерала или вызвать функцию `BigInt`, которая создаст `BigInt` число из переданного аргумента. Аргументом может быть число, строка и др.   

```js
const bigint = 1234567890123456789012345678901234567890n;
const sameBigint = BigInt("1234567890123456789012345678901234567890");
const bigintFromNumber = BigInt(10); // тоже самое что и 10n
```

## Математические операторы

`BigInt` может использоваться как обычные числа, к примеру:

```js run
alert(1n + 2n); // 3
alert(5n / 2n); // 2
```

Обратите внимание: операция деления `5/2` возвращает результат, округленный до нуля без дробной части. Все операции с числами типа `bigint` возвращают `bigint`.

В математических операциях мы не можем смешивать `bigint` и обычные числа:

```js run
alert(1n + 2); // Error: Cannot mix BigInt and other types
```

We should explicitly convert them if needed: using either `BigInt()` or `Number()`, like this:
Мы должны явно их конвертировать: используя либо `BigInt()`, либо `Number()`, например:

```js run
let bigint = 1n;
let number = 2;
// конвертируем number в bigint
alert(bigint + BigInt(number)); // 3
// конвертируем bigint в number
alert(Number(bigint) + number); // 3
```

Конвертирование bigint в число всегда происходит бесшумно, но если значение bigint слишком велико и не подходит под тип number, то дополнительные биты будут отброшены, что приведет к потере точности.

````smart header="К `BigInt` числам нельзя применить унарный оператор `+`"
Унарный оператор `+value` является хорошо известным способом конвертировать `value` в число.
Данный оператор не поддерживается при работе с `BigInt` числам, чтобы [не сломать](https://github.com/tc39/proposal-bigint/blob/master/ADVANCED.md#dont-break-asmjs) "asm.js". 
```js run
let bigint = 1n;
alert( +bigint ); // SyntaxError: Unexpected identifier
```
````

## Операции сравнения

Операции сравнения, такие как `<`, `>` работают с bigint и обычными числами как обычно:

```js run
alert( 2n > 1n ); // true
alert( 2n > 1 ); // true
```

As numbers and bigints belong to different types, they can be equal `==`, but not strictly equal `===`:
Так как обычные and bigint числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении `==`:

```js run
alert( 1 == 1n ); // true
alert( 1 === 1n ); // false
```

## Логические операции

В `if` или любом другом логическом операторе, bigint число ведёт себя как обычное число.

К примеру, в `if`, bigint `0n` преобразуется в `false`, другие значения преобразуются в `true`:

```js run
if (0n) {
  // никогда не выполнится
}
```

Логические операторы `||`, `&&` и другие также работают с bigint числами как с обычными числами:

```js run
alert( 1n || 2 ); // 1
alert( 0n || 2 ); // 2
```

## Полифилы

Создание полифила для `BigInt` достаточно не простая задача. Причина в том, что многие операторы в JavaScript, такие как `+`, `-` и др., ведут себя по-разному с bigint числами по сравнению с обычными числами.

К примеру, деление bigint числа всегда возвращает целое число.

Чтобы эмулировать такое поведение, полифилл должен будет заменить поведение всех таких операторов. Такая реализация будет тяжеловесной и иметь негативное влияние на производительсность.

Вот почему на данный момент нет хорошо реализованного полифила.

Существует альтернативное решение предложеное разработчиками [https://github.com/GoogleChromeLabs/jsbi](JSBI) библиотеки.

Они предлагают использовать методы JSBI библиотеки вместо собственной реализации bigint чисел JavaScript интерпретатора:

| Операция | BigInt | JSBI |
|-----------|-----------------|------|
| Создание с `number` | `a = BigInt(789)` | `a = JSBI.BigInt(789)` |
| Сложение | `c = a + b` | `c = JSBI.add(a, b)` |
| Вычитание	| `c = a - b` | `c = JSBI.subtract(a, b)` |
| ... | ... | ... |

...а затем использовать "polyfill" (плагин Babel) для замены вызовов JSBI в использование нативных bigint чисел для браузеров, в которые имеется поддержка `BigInt`.

Другими словами, данный подход предлагает использовать JSBI вместо использования нативных bigint чисел. JSBI внутри себя работает с числами как с bigint числами с соблюдением требований спецификации. Таким образом, мы можем выполнять код в интерпретаторах, которые не поддерживают `BigInt`. 

## References

- MDN: [BigInt](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/BigInt).
- Спецификация: [BigInt](https://tc39.es/ecma262/#sec-bigint-objects).
