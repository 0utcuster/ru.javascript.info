# Паттерны и флаги

Регулярные выражения – мощное средство поиска и замены в строке.

В JavaScript регулярные выражения реализованы отдельным объектом `RegExp` и интегрированы в методы строк.

## Регулярные выражения

Регулярное выражение (англ. regexp, оно же "регэксп", "регулярка" или просто "рег"), состоит из *шаблона* (англ. pattern, также говорят "паттерн") и необязательных *флагов*.

Существует два синтаксиса создания объекта регулярного выражения.

"Длинный" синтаксис:

```js
regexp = new RegExp("шаблон", "флаги");
```

...И короткий синтаксис, использующий слеши `"/"`:

```js
regexp = /шаблон/; // без флагов
regexp = /шаблон/gmi; // с флагами gmi (будут описаны далее)
```

Слеши `"/"` говорят JavaScript о том, что это регулярное выражение. Они играют здесь ту же роль, что и кавычки для обозначения строк.

## Использование

Для поиска внутри строки мы можем использовать метод [search](mdn:js/String/search).

Вот простой пример:

```js run
let str = "Я люблю JavaScript!"; // будем искать в этой строке

let regexp = /люблю/;

alert( str.search(regexp) ); // 2
```

Метод `str.search` ищет `pattern:/люблю/` и возвращает позицию внутри строки. Как можно догадаться, `pattern:/люблю/` - простейший возможный шаблон. То, что он делает -  это обычный поиск подстроки.

Код выше - то же самое, что и:

```js run
let str = "Я люблю JavaScript!"; // будем искать в этой строке

*!*
let substr = 'люблю';
*/!*

alert( str.search(substr) ); // 2
```

Поиск `pattern:/люблю/` - то же самое, что поиск `'люблю'`.

Но это лишь пока. Очень скоро мы создадим более сложные регулярные выражения, и тогда увидим, что они гораздо мощнее.

```smart header="Цветовые обозначения"
Здесь и далее в тексте используется следующая цветовая схема:

- регулярное выражение -- `pattern:красный`
- строка (там где происходит поиск) -- `subject:синий`
- результат -- `match:зелёный`
```


````smart header="Когда использовать `new RegExp`?"
Обычно мы используем короткий синтаксис `/.../`. Но он не поддерживает вставки переменных `${...}`.

С другой стороны, `new RegExp` позволяет динамически создавать шаблон из строки.

Таким образом, мы можем выяснить, что нам нужно искать и создать из этого `new RegExp`:

```js run
let tag = prompt("Что вы хотите найти?", "h2");
let regexp = new RegExp(`<${tag}>`);

// при ответе по умолчанию (h2) найдёт <h2>
alert( "<h1> <h2> <h3>".search(regexp));
```
````


## Флаги

Регулярные выражения могут иметь флаги, которые влияют на поиск.

В JavaScript их всего шесть:

`i`
: С этим флагом поиск не зависит от регистра: нет разницы между `A` и `a` (см. пример ниже).

`g`
: С этим флагом поиск ищет все совпадения, без него - только первое.

`m`
: Многострочный режим (рассматривается в главе <info:regexp-multiline-mode>).

`s`
: Включает режим "dotall", при котором точка `pattern:.` может соответствовать символу перевода строки `\n` (рассматривается в главе <info:regexp-character-classes>).

`u`
: Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар (подробнее об этом в главе <info:regexp-unicode>).

`y`
: Режим закрепления (описан в главе <info:regexp-sticky>)

Мы рассмотрим все эти флаги далее в этом учебнике.

На данный момент мы уже можем использовать флаг `i`, для регистро-независимого поиска вот пример:

```js run
let str = "Я люблю JavaScript!";

alert( str.search(/ЛЮБЛЮ/i) ); // 2 (найдено в нижнем регистре)

alert( str.search(/ЛЮБЛЮ/) ); // -1 (без флага 'i' ничего не найдено)
```

Таким образом, уже просто флаг `i` делает регулярные выражения более мощными, нежели чем простой поиск по подстроке. Но это только начало. Мы рассмотрим другие флаги и функции в следующих главах.

## Методы поиска

Существует два набора методов для работы с регулярными выражениями.

1. Во-первых, регулярные выражения являются объектами встроенного класса [RegExp](mdn:js/RegExp), он предоставляет много методов.
2. Кроме того, в обычных строках есть методы, которые могут работать с регулярными выражениями.

Так что одно и то же можно делать разными путями.

Для начала будем использовать 3 метода:

- `str.search(regexp)` - возвращает позицию совпадения с `regexp` в строке `str`, или `-1`, если совпадения нет.
- `str.match(regexp)` - возвращает первое совпадение с `regexp` в строке `str` или `null`, если совпадений нет. При наличии у регулярного выражения флага `g`, возвращает массив всех совпадений.
- `str.replace(regexp, replacement)` - заменяет совпадения с `regexp` на `replacement`: все, если у регулярного выражения есть флаг `g`, иначе только первое.

Например:

```js run
// в строке смешаный регистр, но мы будем использовать флаг i
let str = "ЛюБлЮ JavaScript!";

alert( str.match(/люблю/i) ); // ЛюБлЮ (само совпадение)
alert( str.search(/люблю/i) ); // 0 (на позиции 0)
alert( str.replace(/люблю/i, 'ненавижу')); // ненавижу JavaScript!
```

Позже, в главе `<info:regexp-methods>` мы разберём и другие методы.

## Итого

- Регулярное выражение состоит из шаблона и необязательных флагов: `g`, `i`, `m`, `u`, `s`, `y`.
- Без флагов и специальных символов, которые мы изучим позже, поиск по регулярному выражению аналогичен поиску по подстроке.
- Метод `str.search(regexp)` возвращает индекс, в котором найдено совпадение.
- Метод `str.match(regexp)` возвращает первое совпадение или, если есть флаг `g`, то массив всех совпадений.
- Метод `str.replace(regexp, replacement)` заменяет совпадения с `regexp` на `replacement`: все, если у регулярного выражения есть флаг `g`, иначе только первое.
