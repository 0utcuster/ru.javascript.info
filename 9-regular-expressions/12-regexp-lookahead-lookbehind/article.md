# Опережающие и ретроспективные проверки

В некоторых случаях нам нужно найти соответствие шаблону, за которым следует другой шаблон.

Например, мы хотим найти стоимость (число) только если после него есть знак валюты `subject:€`, для того чтобы получить цену из строк вида: `subject:1 индейка стоит 30€`.

Это позволяет сделать опережающая проверка.

## Опережающая проверка

Синтаксис: `pattern:x(?=y)`.

Он означает: найди `pattern:х` при условии, что за ним следует `pattern:y`.

Для целого числа, за которым идёт знак `subject:€`, шаблон регулярного выражения будет `pattern:\d+(?=€)`:

```js run
let str = "1 индейка стоит 30€";

alert( str.match(/\d+(?=€)/) ); // 30, число 1 проигнорировано, так как за ним НЕ следует €
```

Допустим, нам нужно узнать из этой же строки количество индеек, то есть число `pattern:\d+`, за которым НЕ следует знак `subject:€`.

Для этой задачи мы можем применить негативную опережающую проверку.

Синтаксис: `pattern:x(?!y)`

Он означает: найди такой `pattern:х`, за которым НЕ следует `pattern:y`.

```js run
let str = "2 индейки стоят 60€";

alert( str.match(/\d+(?!€)/) ); // 2 (в этот раз проигнорирована цена)
```

## Ретроспективная проверка

Опережающие проверки позволяют задавать условия на то, что "идёт после".

Ретроспективная проверка выполняет такую же функцию, но с просмотром назад. Другими словами, она находит соответствие шаблону, только если перед ним есть что-то заранее определённое.

Синтаксис:
- Позитивная ретроспективная проверка: `pattern:(?<=y)x`, ищет совпадение с `pattern:x` при условии, что перед ним ЕСТЬ `pattern:y`.
- Негативная ретроспективная проверка: `pattern:(?<!y)x`, ищет совпадение с `pattern:x` при условии, что перед ним НЕТ `pattern:y`.

Чтобы протестировать ретроспективную проверку, давайте поменяем валюту на доллары США. Знак доллара обычно ставится перед суммой денег, поэтому для того чтобы найти `$30`, мы используем `pattern:(?<=\$)\d+` - число, перед которым идёт `subject:$`:

```js run
let str = "1 индейка стоит $30";

// знак доллара $ экранируем, так как это специальный символ
alert( str.match(/(?<=\$)\d+/) ); // 30, одинокое число игнорируется
```

Если нам необходимо найти количество индеек -- число, перед которым не идёт `subject:$`, мы можем использовать негативную ретроспективную проверку `pattern:(?<!\$)\d+`:

```js run
let str = "2 индейки стоят $60";

alert( str.match(/(?<!\$)\d+/) ); // 2 (проигнорировалась цена)
```

## Захват групп

Как правило, то что находится внутри скобок, задающих опережающую и ретроспективную проверку, не включается в результат совпадения.

Например, в шаблоне `pattern:\d+(?=€)` знак `pattern:€` не будет включён в результат. Это логично, ведь мы ищем число `pattern:\d+`, а `pattern:(?=€)` - это всего лишь проверка, что за ним идёт знак `subject:€`.

Но в некоторых ситуациях нам может быть интересно захватить и то, что в проверке. Для этого нужно обернуть это в дополнительные скобки.

В следующем примере знак валюты `pattern:(€|kr)` будет включён в результат вместе с суммой:

```js run
let str = "1 индейка стоит 30€";
let reg = /\d+(?=(€|kr))/; // добавлены дополнительные скобки вокруг €|kr

alert( str.match(reg) ); // 30, €
```

Тоже самое можно применить к ретроспективной проверке:

```js run
let str = "1 индейка стоит $30";
let reg = /(?<=(\$|£))\d+/;

alert( str.match(reg) ); // 30, $
```

Заметим, что хотя обычно скобочные группы нумеруются слева направо, ретроспективная проверка является исключением. Скобки в такой проверке идут всегда после основного шаблона.

Поэтому в примере выше примере совпадение с основным шаблоном `pattern:\d+` идёт первым, а результат для `pattern:(\$|£)` - вторым.

## Итого

Опережающая и ретроспективная проверки удобны, когда мы хотим искать шаблон по дополнительному условию на контекст, в котором он находится.

Для простых регулярных выражений мы можем сделать похожую вещь "вручную". То есть, найти все совпадения, независимо от контекста, а затем в цикле отфильтровать подходящие.

Как мы помним, что `str.matchAll` и `reg.exec` возвращают совпадения со свойством `.index`, поэтому мы знаем их точное расположение в тексте и можем посмотреть на контекст.
Но обычно регулярные выражения удобнее.

Виды проверок:

| Паттерн            | Тип                        | Совпадение                      |
|--------------------|----------------------------|---------------------------------|
| `pattern:x(?=y)`   | Позитивная опережающая     | `x`, если за ним следует `y`    |
| `pattern:x(?!y)`   | Негативная опережающая     | `x`, если за ним НЕ следует `y` |
| `pattern:(?<=y)x`  | Позитивная ретроспективная | `x`, если следует за `y`        |
| `pattern:(?<!y)x`  | Негативная ретроспективная | `x`, если НЕ следует за `y`     |

Опережающая проверка также может быть использована, чтобы отключить возврат при поиске. Для чего нам это может понадобиться и другие детали, вы узнаете в следующей главе.
