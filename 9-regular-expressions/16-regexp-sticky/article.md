# Поиск на заданной позиции, флаг "y"

Флаг `pattern:y` позволяет произвести поиск, начиная с определённой позиции в исходной строке.

Чтобы разобрать флаг `pattern:y` и понять, чем же он хорош, рассмотрим практический пример.

Одна из часто встречающихся задач регулярных выражений - лексический разбор: мы имеем текст на каком-то языке программирования и с помощью регулярных выражений (или иным способом) получаем его структурные элементы.

Например, в браузеры встроен лексический анализатор HTML, а также для языка JavaScript.

Мы не будем погружаться глубоко в тему написания таких анализаторов (это специализированная область со своим набором инструментов и алгоритмов). Но в процессе их работы, вообще, в процессе анализа текста, очень часто возникает задача "прочитать что-то на заданной позиции".

Например, у нас есть строка кода `subject:let varName = "value"`, и нам надо прочитать из неё имя переменной, которое начинается с позиции `4`.

Имя переменной будем искать как слово `pattern:\w+`. Вообще, в языке JavaScript для имени переменной нужно чуть более сложное регулярное выражение, но здесь это не важно.

Обычный поиск, такой как `str.match` найдёт только первое слово в строке или все слова (с флагом `pattern:g`), а нам нужно одно слово именно на позиции `4`.

Для использования флага `pattern:y` понадобится метод `regexp.exec(str)`.

Если у регулярного выражения нет флагов `pattern:g` или `pattern:y`, то он ищет первое совпадение с `regexp` в строке `str`, аналогично `str.match(regexp)`. Здесь нас вариант без флагов не интересует.

Если флаг `pattern:g` есть, то он осуществляет поиск в строке `str`, начиная с позиции, заданной свойством `regexp.lastIndex`. И, когда находит, обновляет `regexp.lastIndex` на позицию после совпадения.

При создании регулярного выражения его свойство `lastIndex` равно `0`.

Например (пока без флага `y`):

```js run
let str = 'let varName = "value"';

let regexp = /\w+/g;
alert(regexp.lastIndex); // 0 (при создании lastIndex=0)

let word1 = regexp.exec(str);
alert(word1); // let (первое слово)
alert(regexp.lastIndex); // 3 (позиция за первым совпадением)

let word2 = regexp.exec(str);
alert(word2); // varName (второе слово)
alert(regexp.lastIndex); // 11 (позиция за вторым совпадением)
```

Таким образом, последовательные вызовы `regexp.exec` могут найти все совпадения, представляя собой альтернативу методам `str.match/matchAll`.

Но, в отличие от этих методов, мы можем поставить самостоятельно `lastIndex`, начав тем самым поиск именно с нужной позиции.

Например, найдём слово на позиции `4`:

```js run
let str = 'let varName = "value"';

let regexp = /\w+/g; // без флага g свойство lastIndex игнорируется

*!*
regexp.lastIndex = 4;
*/!*

let word = regexp.exec(str);
alert(word); // varName
```

Поиск `pattern:\w+` произведён, начиная с позиции `regexp.lastIndex = 4`.

Заметим, что такой поиск лишь начинается с позиции `lastIndex` и идёт дальше. Если слова на позиции `lastIndex` нет, но оно есть позже, оно всё равно будет найдено:

```js run
let str = 'let varName = "value"';

let regexp = /\w+/g;
*!*
regexp.lastIndex = 3;
*/!*

let word = regexp.exec(str);
alert(word); // varName
```

...То есть, при флаге `pattern:g` свойство `lastIndex` задаёт *стартовую позицию* поиска.

**Флаг `pattern:y` заставляет `regexp.exec` искать ровно на позиции `lastIndex`, ни до и ни после.**

Вот тот же поиск с флагом `pattern:y`:

```js run
let str = 'let varName = "value"';

let regexp = /\w+/y;

regexp.lastIndex = 3;
alert( regexp.exec(str) ); // null (на позиции 3 пробел, а не слово)

regexp.lastIndex = 4;
alert( regexp.exec(str) ); // varName (слово на позиции 4)
```

Как можно видеть, регулярное выражение `pattern:\w+` не найдено на позиции `3` (в отличие от флага `pattern:g`), но найдено на позиции `4`.

Флаг `pattern:y` позволяет проверять регулярное выражение именно на конкретной позиции. Это очень важно с точки зрения производительности.

При лексическом анализе больших текстов зачастую нужно применять несколько регэкспов на конкретной позиции текста, чтобы понять, что там находится (функция или переменная или число и т.п.)

Без флага `pattern:y` регулярное выражение будет искать, начиная с `lastIndex` и далее по всему тексту, что будет занимать время, особенно, если текст большой. А по всему тексту дальше не надо. Флаг `pattern:y` для подобных задач -- именно то, что нужно.
