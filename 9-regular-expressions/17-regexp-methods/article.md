# Методы RegExp и String

Существует два набора методов для работы с регулярными выражениями.

1. Во-первых, регулярные выражения являются объектами встроенного класса [RegExp](mdn:js/RegExp), он предоставляет много методов.
2. Кроме того, в обычных строках есть методы, которые могут работать с регулярными выражениями.

Так что одно и то же можно делать разными путями.

## Методы строк

Для начала будем использовать 3 метода строк:

- `str.match(reg)` - возвращает совпадение с `reg` в строке `str`.

    Если у `reg` есть флаг `pattern:g`, то возвращает массив всех совпадений в строке `str`, если нет такого флага, то только первое совпадение.

    Если совпадений нет, то возвращает `null`.
- `str.search(reg)` - возвращает позицию первого совпадения с `reg` в строке `str`.
    Если совпадений нет, возвращает `-1`.
- `str.replace(reg, replacement)` - заменяет совпадения с `reg` на `replacement`: все, если у регулярного выражения есть флаг `pattern:g`, иначе только первое.

Например:

```js run
let str = "ЛюБлЮ JavaScript!";

alert( str.match(/люблю/i) ); // ЛюБлЮ (само совпадение)

alert( str.search(/люблю/i) ); // 0 (на позиции 0)

alert( str.replace(/люблю/i, 'ненавижу')); // ненавижу JavaScript!
```

Для замены в методе `replace` можно использовать не только строку, но и функцию.

Она получает результат совпадения в качестве аргумента и возвращает то, на что нужно заменить.

```js run
let str = "ЛюБлЮ JavaScript!";

alert( str.replace(/люблю/i, str => str.toUpperCase()) ); // ЛЮБЛЮ JavaScript!
```



## Другие методы

Есть и другие методы, некоторые из которых мы детальнее разберём позже, когда хорошо изучим регулярные выражения:

- `str.split(reg)` - разбивает строку `str` на части по разделителю, заданному регулярным выражением `reg`.
- `str.matchAll(reg)` - ищет все совпадения с `reg` в строке, аналогично `match`, но даёт больше деталей, нужен при использовании в регулярном выражении скобок, подробнее разберём в уроке <info:regexp-groups>.



Причина в том, что итератор не является массивом. Нам нужно запустить на нем `Array.from (result)` или использовать цикл `for..of` для получения совпадений.

На практике, если нам нужны все совпадения, то `for..of` работает, так что это не проблема.

А, чтобы получить только несколько совпадений, мы можем использовать деструктуризацию:

```js run
let str = "Javascript or JavaScript??";

*!*
let [firstMatch] = str.matchAll( /javascript/ig );
*/!*

alert(firstMatch); // Javascript
```

## str.split(reg|substr, limit)

Разбивает строку в массив по разделителю – регулярному выражению reg или подстроке substr.

Обычно мы используем метод `split` со строками, вот так:

```js run
alert('12-34-56'.split('-')) // массив [12, 34, 56]
```

Но мы можем разделить по регулярному выражению, таким же образом:

```js run
alert('12-34-56'.split(/-/)) // массив [12, 34, 56]
```

## str.replace(str|reg, str|func)

Это универсальный метод поиска-и-замены, один из самых полезных. Этакий швейцарский армейский нож для поиска и замены.

Мы можем использовать его и без регулярных выражений, для поиска-и-замены подстроки:

```js run
// заменить тире двоеточием
alert('12-34-56'.replace("-", ":")) // 12:34-56
```

Хотя есть подводный камень.

**Когда первый аргумент `replace` является строкой, он ищет только первое совпадение.**

Вы можете видеть это в приведённом выше примере: только первый `"-"` заменяется на `":"`.

Чтобы найти все тире, нам нужно использовать не строку `"-"`, а регулярное выражение `/-/g` с обязательным флагом `pattern:g`:

```js run
// заменить все тире двоеточием
alert( '12-34-56'.replace( *!*/-/g*/!*, ":" ))  // 12:34:56
```

Второй аргумент - строка замены. Мы можем использовать специальные символы в нем:

| Спецсимволы | Действие в строке замены |
|--------|--------|
|`$$`|вставляет `"$"` |
|`$&`|вставляет всё найденное совпадение|
|<code>$&#096;</code>|вставляет часть строки до совпадения|
|`$'`|вставляет часть строки после совпадения|
|`$n`|если `n` это 1-2 значное число, то это означает, что содержимое n-й скобки считается слева направо, в противном случае это означает круглую скобку с указанным именем|


Например, если мы используем `$&` в строке замены, это означает "поместить все совпадение здесь".

Давайте используем его для добавления ко всем записям `"John"` строки `"Mr."`:

```js run
let str = "John Doe, John Smith and John Bull";

// для каждого John - заменить его на Mr., а затем добавить John
alert(str.replace(/John/g, 'Mr.$&'));  // Mr.John Doe, Mr.John Smith and Mr.John Bull
```

Довольно часто мы хотим повторно использовать части исходной строки, рекомбинировать их в замене или обернуть во что-нибудь.

Для этого мы должны:
1. Отметить нужные части скобками в регулярном выражении.
2. Использовать `$1`, `$2` (и т.д.) в строке замены, чтобы получить содержимое, соответствующее 1-м, 2-м и так далее скобкам.

Например:

```js run
let str = "Афанасий Фет";

// поменять местами имя и фамилию
alert(str.replace(/(фет) (афанасий)/i, '$2, $1')) // Фет, Афанасий
```

**Для ситуаций, которые требуют "умных" замен, вторым аргументом может быть функция.**

Он будет вызываться для каждого совпадения, и его результат будет вставлен в качестве замены.

Например:

```js run
let i = 0;

// заменить каждое "хо" на результат функции
alert("Хо-Хо-хо".replace(/хо/gi, function() {
  return ++i;
})); // 1-2-3
```

В приведённом выше примере функция просто возвращает следующий номер каждый раз, но обычно результат основан на совпадении.

Функция вызывается с аргументами `func(str, p1, p2, ..., pn, offset, input, groups)`:

1. `str` -- найденное совпадение,
2. `p1, p2, ..., pn` -- содержимое скобок (если есть),
3. `offset` -- позиция, на которой найдено совпадение,
4. `input` -- исходная строка,
5. `groups` -- объект с именованными группами (см. главу [](info:reg-groups)).

Если в регулярном выражении нет скобок, то есть только 3 аргумента: `func(str, offset, input)`.

Давайте используем его, чтобы показать полную информацию о совпадениях:

```js run
// вывести и заменить все совпадения
function replacer(str, offset, input) {
  alert(`Найдено: ${str} на позиции: ${offset} в строке: ${input}`);
  return str.toLowerCase();
}

let result = "ОЙ-Ой-ой".replace(/ой/gi, replacer);
alert( 'Результат: ' + result ); // Результат: ой-ой-ой

// показывает каждое совпадение:
// Найдено: ОЙ на позиции: 0 в строке: ОЙ-Ой-ой
// Найдено: Ой на позиции: 3 в строке: ОЙ-Ой-ой
// Найдено: ой на позиции: 6 в строке: ОЙ-Ой-ой
```

В приведённом ниже примере есть две скобки, поэтому `replacer` вызывается с 5 аргументами: `str` - полное совпадение, затем круглые скобки, а затем `offset` и` input`:

```js run
function replacer(str, name, surname, offset, input) {
  // name - первые скобки, surname - второе
  return surname + ", " + name;
}

let str = "Афанасий Фет";

alert(str.replace(/(Афанасий) (Фет)/, replacer)) // Фет, Афанасий
```

Использование функции даёт нам  максимальные возможности по замене, потому что функция получает всю информацию о совпадении, имеет доступ к внешним переменным и может делать все что угодно.

## reg.exec(str)

Мы уже видели эти методы поиска:

- `search` -- ищет позицию совпадения,
- `match` -- если флаг `pattern:g` отсутствует, возвращает первое совпадение с круглыми скобками и всеми деталями,
- `match` -- если есть флаг `pattern:g` - возвращает все совпадения без подробных скобок,
- `matchAll` -- возвращает все совпадения с деталями.

Метод `reg.exec` является наиболее гибким методом поиска из всех. В отличие от предыдущих методов, `exec` должен вызываться на регулярном выражении, а не на строке.

Он ведёт себя по-разному в зависимости от того, имеет ли регулярное выражение флаг `pattern:g`.

Если нет `pattern:g`, то `reg.exec(str)` возвращает первое совпадение в точности как `str.match(reg)`. Такое поведение не даёт нам ничего нового.

Но если есть `pattern:g`, то:
- `reg.exec(str)` возвращает первое совпадение и *запоминает* позицию после него в свойстве `reg.lastIndex`.
- Следующий вызов начинает поиск от `reg.lastIndex` и возвращает следующее совпадение.
- Если совпадений больше нет, то `reg.exec` возвращает `null`, а для `reg.lastIndex` устанавливается значение `0`.

Мы могли бы использовать его, чтобы получить все совпадения с их позициями и группами скобок в цикле, вместо `matchAll`:

```js run
let str = 'Больше о JavaScript на https://javascript.info';

let reg = /javascript/ig;

let result;

while (result = reg.exec(str)) {
  alert( `Найдено ${result[0]} на позиции ${result.index}` );
  // показывает: Найдено JavaScript на позиции 0, затем
  // показывает: Найдено javascript на позиции 15
}
```

Конечно, `matchAll` делает то же самое, по крайней мере, для современных браузеров. Но то, что `matchAll` не может сделать - это поиск с заданной позиции.

Давайте искать с позиции `13`. Нам нужно присвоить `reg.lastIndex=13` и вызвать` reg.exec`:

```js run
let str = 'Больше о JavaScript на https://javascript.info';

let reg = /javascript/ig;
*!*
reg.lastIndex = 13;
*/!*

let result;

while (result = reg.exec(str)) {
  alert( `Найдено ${result[0]} на позиции ${result.index}` );
  // показывает: Found javascript at 31
}
```

Итак, начиная с заданной позиции `13`, есть только одино совпадение.


## reg.test(str)

Метод `reg.test(str)` ищет совпадение и возвращает `true/false`, в зависимости от того, находит ли он его.

Например:

```js run
let str = "Я люблю JavaScript";

// эти два теста делают одно и же
alert( *!*/люблю/i*/!*.test(str) ); // true
alert( str.search(*!*/люблю/i*/!*) != -1 ); // true
```

Пример с отрицательным ответом:

```js run
let str = "Ля-ля-ля";

alert( *!*/люблю/i*/!*.test(str) ); // false
alert( str.search(*!*/люблю/i*/!*) != -1 ); // false
```

Если регулярное выражение имеет флаг `'g'`, то `reg.test` расширяется свойством `reg.lastIndex`, точно так же, как` reg.exec`.

Таким образом, мы можем использовать его для поиска с заданной позиции:

```js run
let reg = /люблю/gi;

let str = "Я люблю JavaScript";

// начать поиск с 10 позиции:
reg.lastIndex = 10
alert( reg.test(str) ); // false (совпадений нет)
```



````warn header="Одно и то же глобальное регулярное выражение, использованное повторно, может иметь другой результат"
Если мы применяем одно и то же глобальное регулярное выражение последовательно к разным строкам, это может привести к неверному результату, поскольку вызов `reg.test` обновляет свойство `reg.lastIndex`, поэтому поиск в новой строке может начаться с ненулевой позиции.

Например, здесь мы дважды вызываем `reg.test` для одного и того же текста, и второй раз поиск завершается уже неудачно:

```js run
let reg = /javascript/g;  // (reg только что создан: reg.lastIndex=0)

alert( reg.test("javascript") ); // true (а теперь reg.lastIndex=10)
alert( reg.test("javascript") ); // false
```

Это именно потому, что во втором тесте `reg.lastIndex` не равен нулю.

Чтобы обойти это, можно использовать неглобальные регулярные выражения или переприсвоить `reg.lastIndex = 0` перед новым поиском.
````
