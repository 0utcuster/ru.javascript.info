# Введение: шаблоны и флаги

Регулярные выражения – мощное средство поиска и замены в строке.

В JavaScript регулярные выражения реализованы отдельным объектом [RegExp](mdn:js/RegExp) и интегрированы в методы строк.

## Регулярные выражения

Регулярное выражение (оно же "регэксп", "регулярка" или просто "рег"), состоит из *шаблона* (также говорят "паттерн") и необязательных *флагов*.

Существует два синтаксиса для создания регулярного выражения.

"Длинный" синтаксис:

```js
regexp = new RegExp("шаблон", "флаги");
```

...И короткий синтаксис, использующий слеши `"/"`:

```js
regexp = /шаблон/; // без флагов
regexp = /шаблон/gmi; // с флагами gmi (будут описаны далее)
```

Слеши `pattern:/.../` говорят JavaScript о том, что это регулярное выражение. Они играют здесь ту же роль, что и кавычки для обозначения строк.

Регулярное выражение в обоих случаях является объектом `RegExp`.

Основная разница между этими двумя способами создания заключается в том, что слеши `pattern:/.../` не допускают никаких вставок переменных. Они используются, когда мы на момент написания кода точно знаем, каким будет регулярное выражение - и это большинство ситуаций. А `new RegExp` - когда мы хотим создать регулярное выражение "на лету" из динамически сгенерированной строки, например:

```js
let tag = prompt("Что вы хотите найти?", "h2");

let regexp = new RegExp(`<${tag}>`); // то же, что /<h2>/  при ответе "h2" на prompt выше
```

## Флаги

Регулярные выражения могут иметь флаги, которые влияют на поиск.

В JavaScript их всего шесть:

`pattern:i`
: С этим флагом поиск не зависит от регистра: нет разницы между `A` и `a` (см. пример ниже).

`pattern:g`
: С этим флагом поиск ищет все совпадения, без него - только первое.

`pattern:m`
: Многострочный режим (рассматривается в главе <info:regexp-multiline-mode>).

`pattern:s`
: Включает режим "dotall", при котором точка `pattern:.` может соответствовать символу перевода строки `\n` (рассматривается в главе <info:regexp-character-classes>).

`pattern:u`
: Включает полную поддержку юникода. Флаг разрешает корректную обработку суррогатных пар (подробнее об этом в главе <info:regexp-unicode>).

`pattern:y`
: Режим закрепления (описан в главе <info:regexp-sticky>)

```smart header="Цветовые обозначения"
Здесь и далее в тексте используется следующая цветовая схема:

- регулярное выражение -- `pattern:красный`
- строка (там где происходит поиск) -- `subject:синий`
- результат -- `match:зелёный`
```

## Методы

Для начала работы с регулярными выражениями нам будет достаточно трёх методов:

- `str.match(regexp)` - ищет совпадения с `regexp` в строке `str` (все, если у регулярного выражения есть флаг `g`, иначе только первое).
- `str.replace(regexp, replacement)` - заменяет совпадения с `regexp` в строке `str` на `replacement` (все, если есть флаг `g`, иначе только первое).
- `regexp.test(str)` -- проверяет, есть ли хоть одно совпадение, если да, то возвращает `true`, иначе `false`.

```js run
let str = "Я ЛюБлЮ JavaScript";
let reg = /люблю/i;

alert( str.match(reg) ); // ЛюБлЮ (флаг i делает поиск регистро-независимым)
alert( reg.test(str ); // true

alert( str.replace(/люблю/i, 'ненавижу')); // Я ненавижу JavaScript
```

Далее, в процессе изучения регулярных выражений, мы увидим много примеров с ними, а также дополнительные нюансы их работы.

Полная информация о методах собрана в главе <info:regexp-methods>.


## Методы поиска и замены

Существует два набора методов для работы с регулярными выражениями.

1. Во-первых, регулярные выражения являются объектами встроенного класса [RegExp](mdn:js/RegExp), он предоставляет много методов.
2. Кроме того, в обычных строках есть методы, которые могут работать с регулярными выражениями.

Так что одно и то же можно делать разными путями.

### str.search(regexp)

Метод `str.search(regexp)` возвращает позицию совпадения с `regexp` в строке `str` или `-1`, если совпадения нет.

Например:

```js run
let str = "Я люблю JavaScript!"; // будем искать в этой строке

*!*
let regexp = /люблю/;
*/!*

alert( str.search(regexp) ); // 2
```

Метод `str.search` ищет `pattern:/люблю/` и возвращает позицию внутри строки. Как можно догадаться, `pattern:/люблю/` - простейший возможный шаблон. То, что он делает -  это обычный поиск подстроки.

Код выше - работает так же, как обычный `indexOf('люблю')`:

```js run
let str = "Я люблю JavaScript!"; // будем искать в этой строке

*!*
let substr = 'люблю';
*/!*

alert( str.indexOf(substr) ); // 2
```

Чтобы сделать поиск чуть помощнее, добавим флаг `pattern:i` для регистро-независимого поиска:

```js run
let str = "Я люблю JavaScript!";

alert( str.search(/ЛЮБЛЮ/i) ); // 2

alert( str.search(/ЛЮБЛЮ/) ); // -1 (без флага i ничего не найдено)
```

### str.match(regexp)

Метод `str.match(regexp)` возвращает совпадения с `regexp` в строке `str`.

У него есть три режима работы:

1. Если у регулярного выражения есть флаг `pattern:g`, то он возвращает массив всех совпадений:
    ```js run
    let str = "Любо, братцы, любо!";

    alert( str.match(/любо/gi) ); // Любо,любо (массив из 2 совпадений)
    ```

2. Если такого флага нет, то возвращает только первое совпадение в виде объекта, похожего на массив, в котором по индексу `0` находится совпадение, и есть свойства с дополнительной информацией о нём:
    ```js run
    let str = "Любо, братцы, любо!";

    let result = str.match(/любо/i); // без флага g

    alert( result[0] );     // Любо (первое совпадение)
    alert( result.length ); // 1 (без флага g в result всегда 1 элемент)

    // Дополнительная информация:
    alert( result.index );  // 0 (позиция совпадения)
    alert( result.input );  // "Любо, братцы, любо!" (исходная строка)
    ```

3. И, наконец, если совпадений нет, то, вне зависимости от наличия флага `pattern:g`, возвращается `null`.

    Это очень важный нюанс. При отсутствии совпадений возвращается не пустой массив, а именно `null`. Если об этом забыть, можно легко допустить ошибку, например:

    ```js run
    let matches = "JavaScript".match(/HTML/); // = null

    if (!matches.length) { // Ошибка: у null нет свойства length
      alert("Ошибка в строке выше");
    }
    ```

    Если хочется, чтобы результатом всегда был массив, можно написать так:

    ```js run
    let matches = "JavaScript".match(/HTML/)*!* || []*/!*;

    if (!matches.length) {
      alert("Совпадений нет"); // теперь работает
    }
    ```


### str.matchAll(regexp)

[recent browser="new"]

У метода `match` есть два неудобства, которые сложно исправить без потери совместимости со старым кодом. А именно:

- При поиске с флагом `pattern:g` он возвращает массив совпадений, но без деталей.
- Когда совпадений нет, он возвращает `null`, а не пустой массив. Легко заб

Метод `str.matchAll` был добавлен в язык как "более новая" версия `str.match`.

Он тоже ищет совпадения, но есть три отличия:
1. Он возвращает не массив, а перебираемый объект.
2. При поиске с флагом `pattern:g`, он возвращает не просто массив совпадений, а детали для каждого совпадения.

    ```js run
    let result = "Любо, братцы, любо!".matchAll(/любо/gi);

    for(let result)

    let matchAll = str.matchAll(reg);

    alert(matchAll); // [object RegExp String Iterator], не массив, а перебираемый объект


У метода `match` есть два неудобства, которые сложно исправить без потери совместимости со старым кодом. А именно:

- Он возвращает перебираемый об
- Когда совпадений нет, он возвращает `null`, а не пустой массив. Легко заб

1. Если есть флаг `g`, то он возвращает вместе с каждым совпадением содержимое скобочных групп.
2. Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи `Array.from`.


: при наличии флага `pattern:g` он возвращает массив всех совпадений, но без дополнительной информации о каждом.

Часто этого вполне достаточно, но не всегда, и тогда помогает `matchAll`, который умеет возвращать все совпадения со всеми деталями о каждом.

Более подробно примеры на эту тему будут в главе <info:regexp-groups>.


### str.replace(regexp, str|func)

- `str.replace(str|regexp, str|func)` заменяет совпадения с `regexp` на `replacement`: все, если у регулярного выражения `regexp` есть флаг `g`, иначе только первое.

Это универсальный метод поиска-и-замены, один из самых полезных. Этакий швейцарский армейский нож для поиска и замены.

Мы можем использовать его и без регулярных выражений, для поиска-и-замены подстроки:

```js run
// заменить тире двоеточием
alert('12-34-56'.replace("-", ":")) // 12:34-56
```

Хотя есть подводный камень.

**Когда первый аргумент `replace` является строкой, он ищет только первое совпадение.**

Вы можете видеть это в приведённом выше примере: только первый `"-"` заменяется на `":"`.

Чтобы найти все тире, нам нужно использовать не строку `"-"`, а регулярное выражение `pattern:/-/g`, обязательно с флагом `pattern:g`:

```js run
// заменить все тире двоеточием
alert( '12-34-56'.replace( *!*/-/g*/!*, ":" ))  // 12:34:56
```

Второй аргумент - строка замены. Мы можем использовать специальные символы в нем:

| Спецсимволы | Действие в строке замены |
|--------|--------|
|`$$`|вставляет `"$"` |
|`$&`|вставляет всё найденное совпадение|
|<code>$&#096;</code>|вставляет часть строки до совпадения|
|`$'`|вставляет часть строки после совпадения|
|`$n`|если `n` это 1-2 значное число, то это означает, что содержимое n-й скобки считается слева направо, в противном случае это означает круглую скобку с указанным именем|
|`$<name>`|скобка с именем `name`|

Например, если мы используем `$&` в строке замены, это означает "поместить все совпадение здесь".

Давайте используем его для добавления ко всем записям `"John"` строки `"Mr."`:

```js run
let str = "John Doe, John Smith and John Bull";

// для каждого John - заменить его на Mr., а затем добавить John
alert(str.replace(/John/g, 'Mr.$&'));  // Mr.John Doe, Mr.John Smith and Mr.John Bull
```

Примеры с `$n` и `$<name>` мы разберём позже, в главе <info:regexp-groups>.

**Для ситуаций, которые требуют "умных" замен, вторым аргументом может быть функция.**

Она будет вызываться для каждого совпадения, и её результат будет вставлен в качестве замены.

Функция вызывается с аргументами `func(match, p1, p2, ..., pn, offset, input, groups)`:

1. `match` -- найденное совпадение,
2. `p1, p2, ..., pn` -- содержимое скобок (см. главу [](info:regexp-groups)).
3. `offset` -- позиция, на которой найдено совпадение,
4. `input` -- исходная строка,
5. `groups` -- объект с именованными группами (см. главу [](info:regexp-groups)).

Например:

```js run
// заменить каждое "хо" на его позицию в строке
alert("Хо-Хо-хо".replace(/хо/gi, function(match, offset) {
  return offset;
})); // 0-3-6
```

Использование функции даёт нам  максимальные возможности по замене, потому что функция получает всю информацию о совпадении, имеет доступ к внешним переменным и может делать все что угодно.

Если нужно только проверить наличие совпадения, то пригодится другой метод:

- `regexp.test(str)` - возвращает `true`, если строка `str` подходит под `regexp` (есть хотя бы одно совпадение), иначе `false`.

Этот метод вызывается на регулярном выражении и получает строку, например:

```js run
let str = "ЛюБлЮ JavaScript!";

alert( /люблю/i.test(str) ); // true
```

В процессе изучения регулярных выражений мы увидим множество примеров и дополнительные нюансы.

А позже, в главе <info:regexp-methods>, вернёмся к методам и изучим их более подробно. Это имеет смысл делать после того, как мы разберём более сложные регулярные выражения.

## Итого

- Регулярное выражение состоит из шаблона и необязательных флагов: `pattern:g`, `pattern:i`, `pattern:m`, `pattern:u`, `pattern:s`, `pattern:y`.
- Без флагов и специальных символов, которые мы изучим позже, поиск по регулярному выражению аналогичен поиску подстроки.
- Метод `str.search(regexp)` возвращает позицию, на которой найдено совпадение.
- Метод `str.match(regexp)` возвращает первое совпадение или, если есть флаг `pattern:g`, то массив всех совпадений.
- Метод `str.replace(regexp, replacement)` заменяет совпадения с `regexp` на `replacement`: все, если у регулярного выражения есть флаг `pattern:g`, иначе только первое.
- Метод `regexp.test(str)` возвращает `true`, если есть совпадение, иначе `false`.
