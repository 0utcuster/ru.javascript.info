# Символьные классы

Рассмотрим практическую задачу - у нас есть номер телефона `"+7(903)-123-45-67"`, и нам нужно превратить его в строку только из чисел: `79035419441`.

Для этого мы можем найти и удалить все, что не является числом. Символьные классы могут помочь с этим.

Символьный класс - это специальное обозначение, которое соответствует любому символу из определённого набора.

Для начала давайте рассмотрим класс "цифра". Он обозначается как `pattern:\d`. Мы помещаем это обозначение в регулярное выражение, что соответствует "любой одной цифре".

Например, давайте найдём первую цифру в номере телефона:

```js run
let str = "+7(903)-123-45-67";

let reg = /\d/;

alert( str.match(reg) ); // 7
```

Без флага `g` регулярное выражение ищет только первое совпадение, то есть первую цифру `pattern:\d`.

Давайте добавим флаг `g`, чтобы найти все цифры:

```js run
let str = "+7(903)-123-45-67";

let reg = /\d/g;

alert( str.match(reg) ); // массив совпадений: 7,9,0,3,1,2,3,4,5,6,7

alert( str.match(reg).join('') ); // 79035419441
```

Это был символьный класс для цифр. Есть и другие подобные классы.

Наиболее используемые:

`pattern:\d` ("d" от английского "digit" означает "цифра")
: Цифра: символ от `0` до `9`.

`pattern:\s` ("s": от английского "space" – "пробел")
: Символ пробела: включает пробелы, символы табуляции, переводы строк.

`pattern:\w` ("w": от английского "word" – "слово")
: Символ "слова", а точнее – буква латинского алфавита или цифра или подчёркивание `_`. Нелатинские буквы не являются частью `pattern:\w`, то есть буква русского алфавита не подходит.

Для примера, `pattern:\d\s\w` обозначает "цифру", за которой идёт пробельный символ, а затем символ слова, например `"1 a"`.

**Регулярное выражение может содержать как обычные символы, так и символьные классы.**

Например, `pattern:CSS\d` соответствует строке `match:CSS` с цифрой после неё:

```js run
let str = "Есть ли стандарт CSS4?";
let reg = /CSS\d/

alert( str.match(reg) ); // CSS4
```

Также мы можем использовать несколько символьных классов одновременно:

```js run
alert( "I love HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'
```

Соответствие (каждому символьному классу соответствует один символ результата):

![](love-html5-classes.svg)

## Граница слова: \b

Граница слова `pattern:\b` - это специальный символьный класс.

Он обозначает не какой-то конкретный символ, а границу между символами.

Например, `pattern:\bJava\b` соответствует отдельное слово `match:Java` в строке `subject:Hello, Java!`, но не часть слова в `subject: Hello, JavaScript!`.

```js run
alert( "Hello, Java!".match(/\bJava\b/) ); // Java
alert( "Hello, JavaScript!".match(/\bJava\b/) ); // null
```

Символьные классы, которые мы видели ранее, означали символ в результате (например, букву или цифру).

Граница - это проверка, про неё ещё говорят, что она имеет "нулевую ширину".

Когда движок регулярных выражений (программный модуль, реализующий поиск по регулярным выражениям) выполняет поиск, он перемещается по строке в попытке найти совпадение. В каждой позиции строки он пытается найти шаблон.

Когда шаблон содержит `pattern:\b`, он *проверяет*, что позиция в строке является границей слова.

Есть три вида позиций, которые являются границами слова:

- Начало текста, если первый символ `pattern:\w`.
- Внутри текста, если с одной стороны "символ слова" `pattern:\w`, а с другой – не `pattern:\w`.
- Конец текста, если последний символ `pattern:\w`.

Например, в строке `subject:Hello, Java!` следующие позиции соответствуют `pattern:\b`:

![](hello-java-boundaries.svg)

Так что она соответствует регулярному выражению `pattern:\bHello\b`, потому что:

1. В начале строки совпадает первый тест `pattern:\b`.
2. Далее слово `pattern:Hello` совпадает.
3. Далее `pattern:\b` снова совпадает, так как мы находимся между `subject:o` и пробелом.

Шаблон `pattern:\bJava\b` также совпадёт. Но не `pattern:\bHell\b` (потому что после `subject:l` нет границы слова), и не `pattern:Java!\b` (восклицательный знак не является "символом слова" `pattern:\w`, поэтому после него нет границы слова).

```js run
alert( "Hello, Java!".match(/\bHello\b/) ); // Hello
alert( "Hello, Java!".match(/\bJava\b/) );  // Java
alert( "Hello, Java!".match(/\bHell\b/) );  // null (нет совпадения)
alert( "Hello, Java!".match(/\bJava!\b/) ); // null (нет совпадения)
```

Ещё раз отметим, что `pattern:\b` заставляет поисковой движок проверять на наличие границы, поэтому `pattern:Java\b` находит `match:Java` только тогда, когда за ней следует граница слова, но не добавляет символ после границы к результату.

Обычно мы используем `pattern:\b`, чтобы найти отдельные английские слова. Таким образом, если нам нужен `"Java"` язык, то `pattern:\bJava\b` находит только отдельное слово и ничего не находит, когда оно является частью, как в `"JavaScript"`.

Другой пример: регулярное выражение `pattern:\b\d\d\b` ищет отдельно стоящие двузначные числа. Другими словами, требуется, чтобы до и после `pattern:\d\d` был символ, отличный от `pattern:\w` (или начало/конец строки)

```js run
alert( "1 23 456 78".match(/\b\d\d\b/g) ); // 23,78
```

```warn header="Граница слова не работает для алфавитов, не основанных на латинице"
Проверка границы слова `pattern:\b` проверяет границу между `pattern:\w` и чем-то ещё. Но `pattern:\w` означает английскую букву (или цифру или знак подчёркивания), поэтому тест не будет работать для других символов (например, кириллицы или иероглифов).

Позже мы придём к символьным классам для работы с Юникодом, которые позволяют решать похожие задачи для разных языков.
```


## Обратные символьные классы

Для каждого символьного класса существует "обратный класс", обозначаемый той же буквой, но в верхнем регистре.

"Обратный" означает, что он соответствует всем другим символам, например:

`pattern:\D`
: Не цифра: любой символ, кроме `pattern:\d`, например буква.

`pattern:\S`
: Не пробел: любой символ, кроме `pattern:\s`, например буква.

`pattern:\w`
: Любой символ, кроме `pattern:\w`, то есть не буквы из латиницы, не знак подчёркивания и не цифра. В частности, русские буквы принадлежат этому классу.

`pattern:\B`
: Проверка, обратная `pattern:\b`.

В начале главы мы увидели, как получить все цифры из строки с номером телефона `subject:+7(903)-123-45-67`.

Один из способов - это найти все цифры и соединить их:

```js run
let str = "+7(903)-123-45-67";

alert( str.match(/\d/g).join('') ); // 79031234567
```

Альтернативный, более короткий путь - найти нецифровые символы `pattern:\D` и удалить их из строки:


```js run
let str = "+7(903)-123-45-67";

alert( str.replace(/\D/g, "") ); // 79031234567
```

## Пробелы – обычные символы

Обычно мы уделяем мало внимания пробелам. Для нас строки `subject:1-5` и `subject: 1 - 5` практически идентичны.

Но если регулярное выражение не учитывает пробелы, оно может не сработать.

Давайте попробуем найти цифры, разделённые тире:

```js run
alert( "1 - 5".match(/\d-\d/) ); // null, нет совпадения!
```

Исправим это, добавив пробелы в регулярное выражение `pattern:\d - \d`:

```js run
alert( "1 - 5".match(/\d - \d/) ); // 1 - 5, теперь работает
```

**Пробел - это символ. Такой же важный, как любой другой.**

Конечно, пробелы в регулярных выражениях нужны только в том случае, если мы их ищем. Лишние пробелы (как и любые другие лишние символы) могут помешать совпадению:

```js run
alert( "1-5".match(/\d - \d/) ); // null, потому что строка '1-5' не содержит пробелов
```

Другими словами, в регулярном выражении все символы имеют значение, даже пробелы.

## Точка - это любой символ

Точка `"."` - это специальный символьный класс, который соответствует "любому символу, кроме новой строки".

Для примера:

```js run
alert( "Ю".match(/./) ); // Ю
```

Или в середине регулярного выражения:

```js run
let reg = /CS.4/;

alert( "CSS4".match(reg) ); // CSS4
alert( "CS-4".match(reg) ); // CS-4
alert( "CS 4".match(reg) ); // CS 4 (пробел тоже является символом)
```

Обратите внимание, что точка означает "любой символ", но не "отсутствие символа". Там должен быть какой-либо символ, чтобы соответствовать условию поиска:

```js run
alert( "CS4".match(/CS.4/) ); // null, нет совпадений потому что нет символа для точки
```

### Точка, как буквально любой символ, с флагом "s"

Обычно точка не соответствует символу новой строки `\n`.

То есть, `pattern:A.B` соответствует символу `match:A` и затем `match:B`, с любым символом между ними, кроме перевода строки `\n`.

Например, ниже в результате нет совпадений:

```js run
alert( "A\nB".match(/A.B/) ); // null (нет совпадения)
```

Это бывает неудобно, если мы действительно имеем в виду "любой символ", включая перевод строки.

Как раз для этого нужен флаг `s`. Если регулярное выражение имеет его, то точка `"."` соответствует буквально любому символу:

```js run
alert( "A\nB".match(/A.B/s) ); // A\nB (совпадение!)
```

## Итого

Существуют следующие символьные классы:

- `pattern:\d` -- цифры.
- `pattern:\D` -- не цифры.
- `pattern:\s` -- пробельные символы, табы, новые строки.
- `pattern:\S` -- все, кроме `pattern:\s`.
- `pattern:\w` -- латиница, цифры, подчёркивание `'_'`.
- `pattern:\W` -- все, кроме `pattern:\w`.
- `pattern:.` -- любой символ, если с флагом регулярного выражения `'s'`, в противном случае любой символ, кроме перевода строки `\n`.

...Но это не все!

В кодировке Unicode, которую JavaScript использует для строк, каждому символу соответствует ряд свойств, например - какого языка это буква, является ли символ знаком пунктуации, и т.п.

Современный JavaScript позволяет использовать эти свойства в регулярном выражении для поиска, через `pattern:\p{свойства}` например:

- Кириллица: `pattern:\p{Script=Cyrillic}` или `pattern:\p{sc=Cyrillic}`.
- Тире (будь то короткое `-` или длинное тире `—`): `pattern:\p{Dash_Punctuation}` или `pattern:\p{pd}`.
- Обозначение валюты, как например, `pattern:\p{Currency_Symbol}` или `pattern:\p{sc}`.
- ...И многое другое. Юникод имеет много категорий символов, которые мы можем выбрать.

Для работы этих шаблонов необходим флаг регулярного выражения `'u'`. Подробнее о юникодных свойствах - в главе [](info:regexp-unicode).
