# Методы RegExp и String

В этой главе мы рассмотрим все детали методов для работы с регулярными выражениями.

## str.match

Метод `str.match(regexp)` ищет совпадения с `regexp` в строке `str`.

У него есть три режима работы:


1. Если у регулярного выражения нет флага `pattern:g`, то он возвращает первое совпадение в виде массива со скобочными группами и индексом:

    ```js run
    let str = "I love JavaScript";

    let result = str.match(/Java(Script)/);

    alert( result[0] );     // JavaScript (всё совпадение)
    alert( result[1] );     // Script (первые собки)
    alert( result.length ); // 2

    // Дополнительная информация:
    alert( result.index );  // 0 (позиция совпадения)
    alert( result.input );  // "I love JavaScript (исходная строка)
    ```

2. Если у регулярного выражения есть флаг `pattern:g`, то он возвращает массив всех совпадений, без скобочных групп и других деталей.
    ```js run
    let str = "I love JavaScript";

    let result = str.match(/Java(Script)/g);

    alert( result[0] ); // JavaScript
    alert( result.length ); // 1
    ```

3. Если совпадений нет, то, вне зависимости от наличия флага `pattern:g`, возвращается `null`.

    Это очень важный нюанс. При отсутствии совпадений возвращается не пустой массив, а именно `null`. Если об этом забыть, можно легко допустить ошибку, например:

    ```js run
    let str = "I love JavaScript";

    let result = str.match(/HTML/);

    alert(result); // null
    alert(result.length); // Ошибка: у null нет свойства length
    ```

    Если хочется, чтобы результатом всегда был массив, можно написать так:

    ```js
    let result = str.match(regexp) || [];
    ```


## str.matchAll

[recent browser="new"]

Метод `str.matchAll(regexp)` - "новый, улучшенный" вариант метода `str.match`.

Он используется, в первую очередь, для поиска всех совпадений вместе со скобочными группами.

1. Он возвращает не массив, а перебираемый объект с результатами, обычный массив можно сделать при помощи `Array.from`.
2. Каждое совпадение возвращается в виде массива со скобочными группами (как `str.match` без флага `pattern:g`).

Например:

```js run
let str = '<h1>Hello, world!</h1>';
let reg = /<(.*?)>/g;

let matchAll = str.matchAll(reg);

alert(matchAll); // [object RegExp String Iterator], не массив, а перебираемый объект

matchAll = Array.from(matchAll); // теперь массив

let firstMatch = matchAll[0];
alert( firstMatch[0] );  // <h1>
alert( firstMatch[1] );  // h1
alert( firstMatch.index );  // 0
alert( firstMatch.input );  // <h1>Hello, world!</h1>
```

При переборе результатов `matchAll` в цикле `for..of` вызов `Array.from`, разумеется, не нужен.

## str.split(reg|substr, limit)

Разбивает строку в массив по разделителю – регулярному выражению reg или подстроке substr.

Обычно мы используем метод `split` со строками, вот так:

```js run
alert('12-34-56'.split('-')) // массив [12, 34, 56]
```

Но мы можем разделить по регулярному выражению аналогичным образом:

```js run
alert('12, 34, 56'.split(/,\s*/)) // массив [12, 34, 56]
```

## str.searсh

Метод `str.search(regexp)` возвращает позицию первого совпадения с `regexp` в строке `str` или `-1`, если совпадения нет.

Например:

```js run
let str = "Я люблю JavaScript!";

*!*
let regexp = /Java.+/;
*/!*

alert( str.search(regexp) ); // 8
```

## str.replace(str|reg, str|func)

Это универсальный метод поиска-и-замены, один из самых полезных. Этакий швейцарский армейский нож для поиска и замены в строке.

Мы можем использовать его и без регулярных выражений, для поиска-и-замены подстроки:

```js run
// заменить тире двоеточием
alert('12-34-56'.replace("-", ":")) // 12:34-56
```

Хотя есть подводный камень.

**Когда первый аргумент `replace` является строкой, он ищет только первое совпадение.**

Вы можете видеть это в приведённом выше примере: только первый `"-"` заменяется на `":"`.

Чтобы найти все тире, нам нужно использовать не строку `"-"`, а регулярное выражение `/-/g` с обязательным флагом `pattern:g`:

```js run
// заменить все тире двоеточием
alert( '12-34-56'.replace( *!*/-/g*/!*, ":" ))  // 12:34:56
```

Второй аргумент - строка замены. Мы можем использовать специальные символы в нем:

| Спецсимволы | Действие в строке замены |
|--------|--------|
|`$$`|вставляет `"$"` |
|`$&`|вставляет всё найденное совпадение|
|<code>$&#096;</code>|вставляет часть строки до совпадения|
|`$'`|вставляет часть строки после совпадения|
|`$n`|если `n` это 1-2 значное число, то вставляет содержимое n-й скобки| считается слева направо, в противном случае это означает круглую скобку с указанным именем|
|`$<имя>`|вставояет содержимое скобки с указанным именем|

Например:

```js run
let str = "John Smith";

// поменять местами имя и фамилию
alert(str.replace(/(\w+) (\w+)/i, '$2, $1')) // Smith, John
```

**Для ситуаций, которые требуют "умных" замен, вторым аргументом может быть функция.**

Она будет вызываться для каждого совпадения, и её результат будет вставлен в качестве замены.

Функция вызывается с аргументами `func(match, p1, p2, ..., pn, offset, input, groups)`:

1. `match` -- найденное совпадение,
2. `p1, p2, ..., pn` -- содержимое скобок (см. главу [](info:regexp-groups)).
3. `offset` -- позиция, на которой найдено совпадение,
4. `input` -- исходная строка,
5. `groups` -- объект с содержимым именованных скобок (см. главу [](info:regexp-groups)).

Например, переведём выбранные совпадения в верхний регистр:

```js run
let str = "html and css";

let result = str.replace(/html|css/gi, str => str.toUpperCase());

alert(result); // HTML and CSS
```

Заменим каждое совпадение на его позицию в строке:

```js run
alert("Хо-Хо-хо".replace(/хо/gi, (match, offset) => offset)); // 0-3-6
```

Используем содержимое скобок:

```js run
let str = "John Smith";

let result = str.replace(/(\w+) (\w+)/, (match, name, surname) => `${surname}, ${name}`);

alert(result); // Smith, John
```

Если в регулярном выражении много скобочных групп, то бывает удобно использовать остаточные аргументы для обращения к ним:

```js run
let str = "John Smith";

let result = str.replace(/(\w+) (\w+)/, (...match) => `${match[2]}, ${match[1]}`);

alert(result); // Smith, John
```

Или, если мы используем именованные группы, то объект `groups` с ними всегда идёт последним, так что можно получить его так:

```js run
let str = "John Smith";

let result = str.replace(/(?<name>\w+) (?<surname>\w+)/, (...match) => {
  let groups = match.pop();

  return `${groups.surname}, ${groups.name}`;
});

alert(result); // Smith, John
```

Использование функции даёт нам  максимальные возможности по замене, потому что функция получает всю информацию о совпадении, имеет доступ к внешним переменным и может делать всё, что угодно.


## reg.exec(str)

Мы уже видели эти методы поиска:

- `search` -- ищет позицию совпадения,
- `match` -- если флаг `pattern:g` отсутствует, возвращает первое совпадение с круглыми скобками и всеми деталями,
- `match` -- если есть флаг `pattern:g` - возвращает все совпадения без подробных скобок,
- `matchAll` -- возвращает все совпадения с деталями.

Метод `reg.exec` является наиболее гибким методом поиска из всех. В отличие от предыдущих методов, `exec` должен вызываться на регулярном выражении, а не на строке.

Он ведёт себя по-разному в зависимости от того, имеет ли регулярное выражение флаг `pattern:g`.

Если нет `pattern:g`, то `reg.exec(str)` возвращает первое совпадение в точности как `str.match(reg)`. Такое поведение не даёт нам ничего нового.

Но если есть `pattern:g`, то:
- `reg.exec(str)` возвращает первое совпадение и *запоминает* позицию после него в свойстве `reg.lastIndex`.
- Следующий вызов начинает поиск от `reg.lastIndex` и возвращает следующее совпадение.
- Если совпадений больше нет, то `reg.exec` возвращает `null`, а для `reg.lastIndex` устанавливается значение `0`.

Мы могли бы использовать его, чтобы получить все совпадения с их позициями и группами скобок в цикле, вместо `matchAll`:

```js run
let str = 'Больше о JavaScript на https://javascript.info';

let reg = /javascript/ig;

let result;

while (result = reg.exec(str)) {
  alert( `Найдено ${result[0]} на позиции ${result.index}` );
  // показывает: Найдено JavaScript на позиции 0, затем
  // показывает: Найдено javascript на позиции 15
}
```

Конечно, `matchAll` делает то же самое, по крайней мере, для современных браузеров. Но то, что `matchAll` не может сделать - это поиск с заданной позиции.

Давайте искать с позиции `13`. Нам нужно присвоить `reg.lastIndex=13` и вызвать` reg.exec`:

```js run
let str = 'Больше о JavaScript на https://javascript.info';

let reg = /javascript/ig;
*!*
reg.lastIndex = 13;
*/!*

let result;

while (result = reg.exec(str)) {
  alert( `Найдено ${result[0]} на позиции ${result.index}` );
  // показывает: Found javascript at 31
}
```

Итак, начиная с заданной позиции `13`, есть только одино совпадение.


## reg.test(str)

Метод `reg.test(str)` ищет совпадение и возвращает `true/false`, в зависимости от того, находит ли он его.

Например:

```js run
let str = "Я люблю JavaScript";

// эти два теста делают одно и же
alert( *!*/люблю/i*/!*.test(str) ); // true
alert( str.search(*!*/люблю/i*/!*) != -1 ); // true
```

Пример с отрицательным ответом:

```js run
let str = "Ля-ля-ля";

alert( *!*/люблю/i*/!*.test(str) ); // false
alert( str.search(*!*/люблю/i*/!*) != -1 ); // false
```

Если регулярное выражение имеет флаг `'g'`, то `reg.test` расширяется свойством `reg.lastIndex`, точно так же, как` reg.exec`.

Таким образом, мы можем использовать его для поиска с заданной позиции:

```js run
let reg = /люблю/gi;

let str = "Я люблю JavaScript";

// начать поиск с 10 позиции:
reg.lastIndex = 10
alert( reg.test(str) ); // false (совпадений нет)
```



````warn header="Одно и то же глобальное регулярное выражение, использованное повторно, может иметь другой результат"
Если мы применяем одно и то же глобальное регулярное выражение последовательно к разным строкам, это может привести к неверному результату, поскольку вызов `reg.test` обновляет свойство `reg.lastIndex`, поэтому поиск в новой строке может начаться с ненулевой позиции.

Например, здесь мы дважды вызываем `reg.test` для одного и того же текста, и второй раз поиск завершается уже неудачно:

```js run
let reg = /javascript/g;  // (reg только что создан: reg.lastIndex=0)

alert( reg.test("javascript") ); // true (а теперь reg.lastIndex=10)
alert( reg.test("javascript") ); // false
```

Это именно потому, что во втором тесте `reg.lastIndex` не равен нулю.

Чтобы обойти это, можно использовать неглобальные регулярные выражения или переприсвоить `reg.lastIndex = 0` перед новым поиском.
````
